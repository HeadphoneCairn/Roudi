

==========================

Design:
- Plaats voor 8 x 22 characters   => eigenlijk 8 x 21
    1234567890123456789012
   ························
   ·                      ·1
   ·                      ·2
   ·                      ·3
   ·                      ·4
   ·                      ·5
   ·                      ·6
   ·                      ·7
   ·                      ·8
   ························

- Of dunnere characters: 8 x 32
    12345678901234567890123456789012
   ··································
   ·                                ·1 
   ·                                ·2
   ·                                ·3
   ·                                ·4
   ·                                ·5
   ·                                ·6
   ·                                ·7
   ·                                ·8
   ··································

--- Opstartscherm ---
 ┐│││┌
█ o o █
 └┐^┌┘


--- Menu's ---

Browsen dmv A/B knoppen.
A en B samen induwen gaat naar A

Eerste lijn is altijd reverse bitmap
Door de andere lijnen kan je scrollen dmv up/down, met wrap around
Aanpassing kunnen gemaakt worden dmv left/right

························
·[A - Single          ]·
·01. Piano             ·
·05. Dreadbox          ·
·12. iPad              ·
·13. PC                ·
·02.                   ·
·03.                   ·
·04.                   ·
························
·05.                   ·
·06.                   ·
 07.
 08.
 09.
 10.
 11.
 14.
 15.
 16.


························
·[B - Split           ]·
·L: 05. Dreadbox       ·
·   octave +0|-1|+1    ·
·R: 01. Piano          ·
·   octave +0|-1|+1    ·
·Split note: C4        ·
·                      ·
·<save as>             ·
························


························
·[C - Layer           ]·
·A: 01. Piano          ·
·   always on          ·
·B: 12. iPad           ·
·   when velocity > 50 ·
·                      ·
·                      ·
·<save as>             ·
························


························
·[1 - My favorite spli]·
·L: 05. Dreadbox       ·
·   octave +0|-1|+1    ·
·R: 01. Piano          ·
·   octave +0|-1|+1    ·
·Split note: C4        ·
·                      ·
·<save>                ·
························
 <rename>
 <save as>
 <delete>
 <move up>
 <move down>


························
·[MIDI Settings]       ·
·Input channel       01·
·Output channels   MENU·
·Velocity        normal·      normal|custom|none  (none = velocity 64)
·Custom Velocity   MENU·
·Program change   block·      block|allow   (includes bank select)
·CC Mapping        MENU
·
························


························
·[UI Settings]         ·
·Channel order    alpha·      alpha|numeric (alpha = alphabetical followed by empty)
·Channel number    show·      show|hide     (hide = show only if channel has no name)
·Split inc/dec   octave·      octave|CEA|C major|semitone
·Screen brightness     ·
·                      ·
·                      ·
·                      ·
························

························
·[Monitor]             ·
·On  C 25              ·
·Off C 30              ·
·                      ·
·                      ·
·                      ·
·                      ·
·<panic!>              ·
························

===  Output channels menu ===

························
·[Output channels]     ·
·Piano              01 ·
·Dreadbox           05 ·
·maxvijftienchar    07 ·
·iPad               12 ·
·PC                 13 ·
·...                   ·
························
=> dit is te moeilijk, want moet dan naast alfasortering ook kanaalsortering bijhouden
=> en bovendien is het de relatie met de waarden in  single/split/layer moeilijk 
=> daarom beter gewoon
························
·[Output channels]     ·
·ch01             Piano·
·ch02                  ·
·ch03                  ·
·ch04                  ·
·ch05          Dreadbox·
·ch06                  ·
·ch07   maxvijftienchar·
························
 ch08                  
 ch09                  
 ch10                  
 ch11                  
 ch12              iPad
 ch13                PC
 ch14                  
 ch15                  
 ch16 

 
 
Bij links of recht, toon text input scherm

···························
·[Channel]                ·
·                         ·
·My_save_thing__  16 v X  ·   max 15
·                         ·
·                         ·
·up/down: choose char     ·
·up/down on v: OK         ·
·up/down on X: CANCEL     · 
·left/right: move curso   ·
···························



===  Custom velocity menu ===
························
·[Custom Velocity]     ·
·ppp  16             16·
·pp   32             32·
·p    48             48·
·mp   64             64·
·mf   80             80·
·f    96             70·
·ff  112            100·
························
·fff 127            120·
 
+ misschien wat default dingen: hard, soft, ...
 
 
=== Text input ===

························
·Name of preset:       ·
· My_save_thing__  v X ·   max 15
·                      ·
·                      ·
·up/down: choose char  ·
·up/down on v: OK      ·
·up/down on X: CANCEL  · 
·left/right: move curso·
························

 
 
 
TODO:
- Hoe doorsturen afzetten? 
 

Arduino capaciteit:
● 32K bytes of in-system self-programmable flash program memory
● 1Kbytes EEPROM
● 2Kbytes internal SRAM
 
 
Geheugen gebruik
- Kanalen: 16*16*8 bits = 2048 bits = 256 bytes, 
        maar zou kunnen in 6 bits per char = 16*16*6 = 1536 bits = 192 bytes (a-Z, A-Z, 0-9, spatie, streepje: 26 + 26 + 10 + 1 + 1 = 64)
        beginnen met gewoon op te slaan
- Preset: 
    naam: 16*16*6 bit = 12 bytes
    rest: 5 bytes
- Settings: 
    enkele bytes
 

TODO:
- Meegeleverde font van 5x7 is niet zo geweldig. Meestal is het 4x7. Kan beter.
  128x64
  128/5 = 25


························
·------A - SINGLE------·
·01. Piano            │·
·05. Dreadbox         │·
·12. iPad             │·
·13. PC                ·
·02.                   ·
·03.                   ·
·04.                   ·
························
·06.                   ·
 07.
 08.
 09.
 10.
 11.
 14.
 15.
 16.

=> Nieuw, we tonen rechts een scrollbalk ter grote van wat we zien.

Een functie om 1 lijn af te drukken.
Een klasse met:
- titel
- alle te tonen lijnen:
  voor elke lijn
  - lijn object overgeerfd van  
    - functie die tekst genereert,
    - functie die zegt welk gedeelte geinverteerd moet worden bij selectie
    - functie die opgeroepen wordt bij selectie
    - (functie die opgeroepen wordt bij deselectie )
    - functie voor < en >
    - elke klasse bevat z'n eigen data





/// (1) alfabetisch, no channel number
Erebus 
iPAD
Piano
Typhon
ch02   ==> toch misschien beter channel 02
ch03
ch04
ch06
ch07
ch08
ch09
ch12
ch13
ch14
ch15

/// (2) numerical, no channel number
Piano
ch02
ch03
ch04
Erebus 
ch06
ch07
ch08
ch09
Typhon
iPAD
ch12
ch13
ch14
ch15

/// (3) alfabetisch, with channel number
Erebus, 01
iPAD, 11
Piano, 01
Typhon, 10
ch02
ch03
ch04
ch06
ch07
ch08
ch09
ch12
ch13
ch14
ch15

/// (4) numerical, with channel number
Piano, 01
ch02
ch03
ch04
Erebus, 05
ch06
ch07
ch08
ch09
Typhon, 10
iPAD, 11
ch12
ch13
ch14
ch15








So for split:
- Remap all the second nibbles of all bytes that come in with first nibble 8-E
For layer:
- Keep command bytes 8-E and their data in memory and send them to all necessary channels.

So in reality:
- Buffer commands 8-E.
  Send to one or more channels.
- Convert running status to normal way, if not, we cannot send to multiple channels!
- Send system real time message immediately without delay!
- Send commands F without changing.
- Bij duwen knop 7B notes off sturen?




===============================
 Midi implementatie van Blokas
===============================

Midiboy inherits from 
  MidiboyDisplay,   -> draw on screen functions  + begin()
  MidiboyDIN5MIDI,  -> defineert Stream &dinMidi() const;  + begin()
  MidiboyUSBMIDI,   -> defineert Stream &usbMidi() const;  + think()
  MidiboyInput      -> readInputEvent, setButtonRepeatMs + begin()  + think()
                     
Overridden Midiboy functies:
Midiboy.begin(); // begin  Display, DIN5MIDI en Input
Midiboy.think(); // think  USBMidi en Input

Ons programma::
- setup(): opgeroepen bij start programmable
- loop(): loop dinges
  unsigned long g_eventAt = millis(); .. micros()...


De loop van midichords:
- think -> poll USBMIDI, voor elke knop die ingeduwd is wordt event toegeoegd aan de fifo queue
- processStream op USBMIDI en DIN5MIDI:
	processStream(g_outputQueue, g_decoder[DECODER_USB], Midiboy.usbMidi());
  - leest van de Midiboy.ubsMidi stream met de g_decoder[DECODER_USB] decoder
    en zet de geconverteerde data op g_outputQueue
    // usbMidi is de Stream die we krijgen van MidiboyUSBMIDI
    // g_decoder[DECODER_USB] is een MidiToUsb instantie die kan decoderen, 
    //   deze houdt ook staat bij, dus moet bestaan voor USB en DIN5MIDI
    // g_outputQueue is een fifo die 128 MIDI messages kan bevatten (1 x event, 3 x data)
  processStream(g_outputQueue, g_decoder[DECODER_MIDI], Midiboy.dinMidi());
  - zelfde als voor USB  
- kijk of er buttons zijn ingeduwd in event fifo queue en voer ze uit
- flushOutput(g_outputQueue)
  - schrijf g_outputQueue naar de MIDI USB en DIN5 Stream 
    // dmv encoder UsbToMid (heeft geen state)

Dus loop de hele tijd over:
- Poll knopinput en USB MIDI
- Lees berichten van USB en DIN5 MIDI en converteer MIDI boodschappen
- Voer knopinput uit
- Schrijf geconverteerde MIDI boodschappen naar de USB en DIN5 MIDI

Midi message decode (MidiToUsb)
- midi_event_t event;
  if (decoder.process(stream.read(), event))
Midi message encoder:
- UsbToMidi encoder;
	midi_event_t event;
	uint8_t n = UsbToMidi::process(event, msg);
=> MidiToUsb en UsbToMidi naam is slecht gekozen, want niks te maken met USB!



MidiToUsb:
- Je kan een "cable" (0-15) zetten om de midi poort te identificeren
- Voor elke byte die binnenkomt roep je process op met als input parameter deze byte en output een midi_event_t
  De functie vult locaal een event in. Als ze vol is returnt ze true en de event. Anders false.
  een midi_event_t bestaat uit:
  - m_event: de cable | een code 
  - m_data[3] => de bytes van het bericht
  

m_event_code:
- One data byte:
  - C: program change
  - D: channel pressure
- Two data bytes:
  - 8: note off, 8.
  - 9: note on, 9.
  - A: key pressure, A.
  - B: control change, B.
  - E: pitch bend, E.
- One byte specials
  - 2: MTC, song select, f1, f3
  - 3: song position, f2
- One byte real time message that can be inserted at any time
  - F: real time, f8, fa-fd
  - 5: single byte system common, f4-f6
- Three bytes sysex:
  - 4: sysex, F0, F7

sysex:
- As many 3 byte events are generated as necessary.
  The last event will contain the ending F7 byte, but might be padded with 00 00
running status
- ipv status + data + data + data komt er uit de decoder
      status + data, status + data, status + data, status + data, ...
  dus running status wordt opgeheven
  merk op dat de interrupt door real time message mooi wordt opgelost 

TODO:
x maak eigen midibody main class zonder de USBMIDI
x maak scrollbar voor menu
- input channel gaat naar output
  andere kanalen: block of send (maar niet voor actieve output kanalen)
- A+B samen => midi monitor
- about knop in settings met:
   RouDi by
   Headphone Cairn
   2021
- make timer om onveranderde menus auto te saven
- eigenlijk zou pitch bend + modulation aan/uit ook in split moeten komen 
  en octave in layer
- misschien kunnen menus wel constant in geheugen,
  MenuSplit zou dan kunnen kiezen tussen huidig instellingen of een preset
  maakt dit de dingen gemakkelijker?  
- Pagina toevoegen met MIDI filters?
  - block all none input channels
  - program change
  - sysex
  - start/stop
  - real time

TODO VERSION 2
- Presets in separate menus
- Naast Single, Split en Layer een extra menu met alle settings (en drie kanalen?)

TODO VERSION 3
- Dynamic switch of configurations?
  When you switch, keep playing the notes on the previous config, until they are released.
  New notes are played on the new config.



Morgen:
x kijken of USB input en output enig nut heeft => kan niet, geen usb host => dus kill USB
x kijken hoe decoder/encoder werkt en of het goed omgaat met sysex, real time, ...
- midi setup:
  - input channel: a
  - output channel 1: b, noten [0, 127], velocity 0-127
           channel 2: c, ...
           channel ... (op dit moment maar twee kanalen mogelijk)


Damn:
Is midi note 60 C3 of C4???
Officieel lijkt het C4 te zijn:
Octave notation is given here in the International Organization for Standardization  ISO system, 
ISO was formed to include/replace the American National Standards Institute (ANSI) and Deutsches 
Institut für Normung (DIN), the German standards institute. 
In this system, middle C (MIDI note number 60) is C4.  A MIDI note number of 69 is used for 
A440 tuning, that is the A note above middle C.










============
 Midihead 2 -> RouDi
============


Scherm is 8 lijnen + 25 tekens en een paar pixels 
  128 = 25 * (4 + 1) + 3
Ik gebruik 24 tekens, laatse 8 pixels is voor cursor


 0123456789012345678901234

·========= SINGLE ========·
·01. Piano               │·
·02.                     │·
·03.                     │·
·04.                      ·
·05. Dreadbox             ·
·06. iPad                 ·
·07.                      ·
···························
...
>None

--------------------------------------------------------------------------------

======== SINGLE =========
01. Piano               │
02.                     │
03.                     │
04.                      
05. Dreadbox             
06. iPad                 
07.                      
...
16.


========= 1. MULTI =========
01. Dreadbox     oct: +1 
    pb/cc: off  vel: 90%   
05. 0123456789  oct: +1 
    pb/cc: on    vel: 0%
SPLIT mode,   split: C4        of LAYER mode
> Save
> Save as
> Rename
> Left
> Right
 
========= ABOUT =========
RouDi by Headphone Cairn
parts by Blokas, ...  
(c) 2021-2022

RouDi = ROUter for miDI messages

- push A or B to switch 
between pages 
- push ^, v to switch
between fields,
<, > to change values
- push A+B to switch
to midi monitor and 
settings

Memory usage: ....

--------------------------------------------------------------------------------
========= DEBUG =========
free memory
size menus

======== MONITOR ========
.....

======== SETTINGS =======
input channel         01
output channels      ...
velocity curve      soft/medium/hard
program change     block/allow
screen brightness      1

======= UTILITIES =======
panic!

--------------------------------------------------------------------------------

Switching between menus is possible using A and B.
Switching between 


In this menu, the input channel is blocked




The MIDI is always being routed, in all menus. So the MIDI monitor shows
the messages coming in and going out (double when split)
Note that in the About Menu, the input channels is not routed to out.

Wer are doing autosave, which means:
- If the user stays in the same menu for the amount of time and has made a
  change, that menu will be saved.
- If the user switches from menu X to menu Y and had changed menu X, it will
  be saved.
- Same goes for settings. Upon switch (or timeout of 5 minutes), they will 
  be saved.
- We have 100.000 erase/write cycles, so, that's quite good.

In memory:
- current menu
  selected field in all menus
  the midi routing data 
  all settings
- number of bytes single: 1
  number of bytes multi: 10

Max channel name: 10 bytes


How to react when midi setting  is changed.
Meaning, what do to with already playing notes, sysex, ...  



=== Menu ===

GetNumberOfFields(line)
  returns number of selectable fields of the line, typical 1
GetLine(line, field=0, 1, None)
  returns the text and if field is selected, the range to invert
OnLine->OnField(line, field, action)
  act on action = SELECT, LEFT, RIGHT

nog altijd combiline gebruiken om waardes te genereren en huidige waarde te bewaren


- line1 = struct van 3 combilines + string
  + GetNumberOfFields()
  + GetLine(field)
  + Onfield()

dus in split constructor:
- line1.channel.value = &channel
        octave  = &octave

in GetNumberOfFields:
-   

GetLine(line, field, what=nrfields/text/, out)
  if what = nrfields
     out.nr = 3
  if what = text
     sprintf(.......)
     out.p = text
     out.selected = selected
  if field = 0 && what = selected
     if field = ....
     out.redraw = ... 


TODO:
x Make single menu
x Make settings menu
x Create menu switching with A and B and A+B
x about menu
  - also show used memory
  - memory used by page classes
  // TODO: bekijk verschil sizeof(Screen::buffer) Screen::buffer_len !!!!
  // TODO: waarom toont hij ABOUT page eerst???  
x Put everything on disk
x Channels menu
x connect menus 
x Save first_line and selected line and field
- save on switch
  x Multi
  x single
  - settings
- save on timer
  x multi
  x single
  - settings
- Make fake Midi Monitor
x Use 12 characters for channels anyway????
- Order of OnStart OnStop Line in Page ... in subclasses
x Allow for single mode, next to split and layer!
- Uitroepteken in namen
- Multi namen beperken tot hoofdletters + nummers + leestekens
- Save the selected page upon timeout: Maybe too much EEPROM access?
- De SaveOnlyIfModified moet eigenlijk gewoon in de data.cpp komen. Dat hoort niet in de pages!
- In de toekomst kijken of de settings-in-memory wel hoeven. Als er niet on-the-fly veel
  settings woren geraadpleegd, dan is gewoon lezen van de EEPROM ook goed. Zoals ik doe 
  voor Single en Multi's.
  (Zou in theorie zelfs in EEPROM_PUT kunnen komen. Altijd eerst lezen om te zien of het
  wel veranderd is.)
- Reactivate timeout = 5 * 1000
- I think I actually can do a new of the pages. If I were to allocate something
  inside the page I would need to free it before freeing the page. I think
  in this way, the heap does not get fragmented. To research online.
  This thought could have made life much easier when creating the UI. :-(
- New setting:
  Other input channels block/pass
- New page
  Midi monitor settings:
  filter x,
  filter Y,
  ...
- Play when velocity is smaller than x%? Useful?
  Implemented as -70%, -80%, -90%, 0%, 10%, 20%, ...  
  Or as <70, <80, <90, >0, >10, >20 ...
- Settings should change MIDI configuration on the fly!
